# Operating System
## Lec5 More memory and Memory Management:
### 1. Some reminders: VIRTUAL MEMORY
VIRTUAL MEMORY is the separation of user logical memory from physical memory
- Only part of the program needs to be in memory for execution
- Logical address space can therefore be much larger than physical address
space
- Allows address spaces to be shared by several processes
- Allows for more efficient process creation
- More programs running concurrently
### 2. Some reminders: Virtual Address Space
Virtual address space – logical view of how process is stored in memory
- Usually start at address 0, contiguous addresses until end of space
- Meanwhile, physical memory organised in page frames
- MMU must map logical to physical
- Virtual memory can be implemented via:
  - Demand paging
  - Demand segmentation
Virtual Memory can be larger than Physical Memory
So we can have a Virtual Address Space
We usually design logical address space for stack to start at Max logical address and grow “down” while heap grows “up”
- Maximises address space use
- Unused address space between the two is hole
- No physical memory needed until heap or stack grows to a given new page
Enables sparse address spaces with holes left for growth, dynamically linked libraries, etc
### 3. Allocating frames to processes
How do we allocate the fixed amount of free memory to our processes? Let’s say we have 2 processes and 93 frames of free memory:
- Assume our system has 128 frames
- The OS itself might use 35 frames (93 left)
- With demand paging all these frames go on the free frame list
- User process starts execution:
  - We get a whole load of page faults
  - Pages need to be retrieved from disk
  - The first 93 get frames off the free frames list
  - But what about the 94th page fault?
  - We need to decide which one to replace!
### 4. Page replacement algorithms
Page replacement schemes (algorithms) are used when there is a new page request, and there is not enough space in the main memory to allocate the new page.
A page replacement algorithm decides which page it should replace so that it can allocate the memory for the new page.
#### Fix 1: First In First Out method (FIFO)
We track all the pages by using a queue in the main memory.
As soon as a page comes in, put it in the queue and continue.
In this way, the oldest page would always be in the front position in the queue.
Now when a new page comes in and there is no space left in memory, we remove the first page in the queue (which is also the oldest one), “push the rest forward” and use the released final position in the queue.
FIFO: Advantages
- Simple to implement with a queue
- Low computational overheads
- Ideal for small systems
FIFO: disadvantages
- Poor performance when lots of incoming pages
- Every frame/page needs to be tracked
- Needs an additional data structure to do so
#### Fix 2: Least Recently Used (LRU) algorithm
In this scheme, when a page fault occurs we replace the least recently used page with a new one.
The page not used for the longest time is replaced with the new one.
The logic here is that if that page hasn’t been used in a long time it’s unlikely
to be used any time soon.
We term this locality of reference
LRU: Advantages
- The page that has not been used for the longest time gets replaced.
- It gives fewer page faults than any other algorithm.
- The algorithm never suffers from the Belady's anomaly (WHY?)
LRU: Disadvantages
- Computationally expensive
- Often needs a specialist hardware design to implement
- Error detection is quite difficult
### 5. Measuring effectiveness of a Page Replacement Algorithm
- A page fault generates an alert for the operating system.
- The OS then retrieves the page from the secondary or virtual memory to the main memory (takes a few ms)
- A high number of page faults can slow down the whole system. Although page faults are common, a large number of page faults may cause the program to crash or terminate unexpectedly.
**The effectiveness of a page replacement algorithm is measured by the number of page fault it generates.**
**The more effective the page replacement algorithm is, the less the number of page faults generated by the algorithm.**